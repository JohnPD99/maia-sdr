#![doc = "Peripheral access API for MAIA SDR microcontrollers (generated using svd2rust v0.36.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Generic peripheral accessor"]
    pub struct Periph<RB, const A: usize> {
        _marker: marker::PhantomData<RB>,
    }
    unsafe impl<RB, const A: usize> Send for Periph<RB, A> {}
    impl<RB, const A: usize> Periph<RB, A> {
        #[doc = "Pointer to the register block"]
        pub const PTR: *const RB = A as *const _;
        #[doc = "Return the pointer to the register block"]
        #[inline(always)]
        pub const fn ptr() -> *const RB {
            Self::PTR
        }
        #[doc = " Steal an instance of this peripheral"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
        #[doc = " that may race with any existing instances, for example by only"]
        #[doc = " accessing read-only or write-only registers, or by consuming the"]
        #[doc = " original peripheral and using critical sections to coordinate"]
        #[doc = " access between multiple new instances."]
        #[doc = ""]
        #[doc = " Additionally, other software such as HALs may rely on only one"]
        #[doc = " peripheral instance existing to ensure memory safety; ensure"]
        #[doc = " no stolen instances are passed to such software."]
        pub unsafe fn steal() -> Self {
            Self {
                _marker: marker::PhantomData,
            }
        }
    }
    impl<RB, const A: usize> core::ops::Deref for Periph<RB, A> {
        type Target = RB;
        #[inline(always)]
        fn deref(&self) -> &Self::Target {
            unsafe { &*Self::PTR }
        }
    }
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " `0`"]
        const ZERO: Self;
        #[doc = " `1`"]
        const ONE: Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                const ZERO: Self = 0;
                const ONE: Self = 1;
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux = Self::Ux::ZERO;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `FieldWriter` you need to call field value setting method"]
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `BitWriter` you need to call bit setting method"]
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<REG, const WI: u8, FI, Safety> FieldWriter<'_, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::ONE << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::ONE) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes bits to a `Writable` register and produce a value."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[doc = ""]
        #[doc = " Values can be returned from the closure:"]
        #[doc = " ```ignore"]
        #[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn from_write<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes 0 to a `Writable` register and produces a value."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn from_write_with_zero<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F) -> REG::Ux
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            let value = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut W {
                    bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                },
            )
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Modifies the contents of the register by reading and then writing it"]
        #[doc = " and produces a value."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.modify(|r, w| {"]
        #[doc = "     let new_bits = r.bits() | 3;"]
        #[doc = "     unsafe {"]
        #[doc = "         w.bits(new_bits);"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     new_bits"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn from_modify<F, T>(&self, f: F) -> T
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> T,
        {
            let bits = self.register.get();
            let mut writer = W {
                bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut writer,
            );
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
}
#[doc = "Maia SDR IP core"]
pub type MaiaSdr = crate::Periph<maia_sdr::RegisterBlock, 0>;
impl core::fmt::Debug for MaiaSdr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MaiaSdr").finish()
    }
}
#[doc = "Maia SDR IP core"]
pub mod maia_sdr {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        product_id: ProductId,
        version: Version,
        control: Control,
        interrupts: Interrupts,
        recorder_control: RecorderControl,
        recorder_next_address: RecorderNextAddress,
        _reserved6: [u8; 0x08],
        spectrometer: Spectrometer,
    }
    impl RegisterBlock {
        #[doc = "0x00 - product_id"]
        #[inline(always)]
        pub const fn product_id(&self) -> &ProductId {
            &self.product_id
        }
        #[doc = "0x04 - version"]
        #[inline(always)]
        pub const fn version(&self) -> &Version {
            &self.version
        }
        #[doc = "0x08 - control"]
        #[inline(always)]
        pub const fn control(&self) -> &Control {
            &self.control
        }
        #[doc = "0x0c - interrupts"]
        #[inline(always)]
        pub const fn interrupts(&self) -> &Interrupts {
            &self.interrupts
        }
        #[doc = "0x10 - recorder_control"]
        #[inline(always)]
        pub const fn recorder_control(&self) -> &RecorderControl {
            &self.recorder_control
        }
        #[doc = "0x14 - recorder_next_address"]
        #[inline(always)]
        pub const fn recorder_next_address(&self) -> &RecorderNextAddress {
            &self.recorder_next_address
        }
        #[doc = "0x20 - spectrometer"]
        #[inline(always)]
        pub const fn spectrometer(&self) -> &Spectrometer {
            &self.spectrometer
        }
    }
    #[doc = "product_id (r) register accessor: product_id\n\nYou can [`read`](crate::Reg::read) this register and get [`product_id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@product_id`] module"]
    #[doc(alias = "product_id")]
    pub type ProductId = crate::Reg<product_id::ProductIdSpec>;
    #[doc = "product_id"]
    pub mod product_id {
        #[doc = "Register `product_id` reader"]
        pub type R = crate::R<ProductIdSpec>;
        #[doc = "Field `product_id` reader - product_id"]
        pub type ProductIdR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - product_id"]
            #[inline(always)]
            pub fn product_id(&self) -> ProductIdR {
                ProductIdR::new(self.bits)
            }
        }
        #[doc = "product_id\n\nYou can [`read`](crate::Reg::read) this register and get [`product_id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ProductIdSpec;
        impl crate::RegisterSpec for ProductIdSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`product_id::R`](R) reader structure"]
        impl crate::Readable for ProductIdSpec {}
    }
    #[doc = "version (r) register accessor: version\n\nYou can [`read`](crate::Reg::read) this register and get [`version::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@version`] module"]
    #[doc(alias = "version")]
    pub type Version = crate::Reg<version::VersionSpec>;
    #[doc = "version"]
    pub mod version {
        #[doc = "Register `version` reader"]
        pub type R = crate::R<VersionSpec>;
        #[doc = "Field `bugfix` reader - bugfix"]
        pub type BugfixR = crate::FieldReader;
        #[doc = "Field `minor` reader - minor"]
        pub type MinorR = crate::FieldReader;
        #[doc = "Field `major` reader - major"]
        pub type MajorR = crate::FieldReader;
        #[doc = "Field `platform` reader - platform"]
        pub type PlatformR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - bugfix"]
            #[inline(always)]
            pub fn bugfix(&self) -> BugfixR {
                BugfixR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - minor"]
            #[inline(always)]
            pub fn minor(&self) -> MinorR {
                MinorR::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - major"]
            #[inline(always)]
            pub fn major(&self) -> MajorR {
                MajorR::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - platform"]
            #[inline(always)]
            pub fn platform(&self) -> PlatformR {
                PlatformR::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        #[doc = "version\n\nYou can [`read`](crate::Reg::read) this register and get [`version::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct VersionSpec;
        impl crate::RegisterSpec for VersionSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`version::R`](R) reader structure"]
        impl crate::Readable for VersionSpec {}
    }
    #[doc = "control (rw) register accessor: control\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`] module"]
    #[doc(alias = "control")]
    pub type Control = crate::Reg<control::ControlSpec>;
    #[doc = "control"]
    pub mod control {
        #[doc = "Register `control` reader"]
        pub type R = crate::R<ControlSpec>;
        #[doc = "Register `control` writer"]
        pub type W = crate::W<ControlSpec>;
        #[doc = "Field `sdr_reset` reader - sdr_reset"]
        pub type SdrResetR = crate::BitReader;
        #[doc = "Field `sdr_reset` writer - sdr_reset"]
        pub type SdrResetW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - sdr_reset"]
            #[inline(always)]
            pub fn sdr_reset(&self) -> SdrResetR {
                SdrResetR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - sdr_reset"]
            #[inline(always)]
            pub fn sdr_reset(&mut self) -> SdrResetW<ControlSpec> {
                SdrResetW::new(self, 0)
            }
        }
        #[doc = "control\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ControlSpec;
        impl crate::RegisterSpec for ControlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`control::R`](R) reader structure"]
        impl crate::Readable for ControlSpec {}
        #[doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
        impl crate::Writable for ControlSpec {
            type Safety = crate::Unsafe;
        }
    }
    #[doc = "interrupts (r) register accessor: interrupts\n\nYou can [`read`](crate::Reg::read) this register and get [`interrupts::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@interrupts`] module"]
    #[doc(alias = "interrupts")]
    pub type Interrupts = crate::Reg<interrupts::InterruptsSpec>;
    #[doc = "interrupts"]
    pub mod interrupts {
        #[doc = "Register `interrupts` reader"]
        pub type R = crate::R<InterruptsSpec>;
        #[doc = "Field `spectrometer` reader - spectrometer"]
        pub type SpectrometerR = crate::BitReader;
        #[doc = "Field `recorder` reader - recorder"]
        pub type RecorderR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - spectrometer"]
            #[inline(always)]
            pub fn spectrometer(&self) -> SpectrometerR {
                SpectrometerR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - recorder"]
            #[inline(always)]
            pub fn recorder(&self) -> RecorderR {
                RecorderR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        #[doc = "interrupts\n\nYou can [`read`](crate::Reg::read) this register and get [`interrupts::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterruptsSpec;
        impl crate::RegisterSpec for InterruptsSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`interrupts::R`](R) reader structure"]
        impl crate::Readable for InterruptsSpec {}
    }
    #[doc = "recorder_control (rw) register accessor: recorder_control\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_control::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`recorder_control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@recorder_control`] module"]
    #[doc(alias = "recorder_control")]
    pub type RecorderControl = crate::Reg<recorder_control::RecorderControlSpec>;
    #[doc = "recorder_control"]
    pub mod recorder_control {
        #[doc = "Register `recorder_control` reader"]
        pub type R = crate::R<RecorderControlSpec>;
        #[doc = "Register `recorder_control` writer"]
        pub type W = crate::W<RecorderControlSpec>;
        #[doc = "Field `start` writer - start"]
        pub type StartW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `stop` writer - stop"]
        pub type StopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `mode` reader - mode"]
        pub type ModeR = crate::FieldReader;
        #[doc = "Field `mode` writer - mode"]
        pub type ModeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `dropped_samples` reader - dropped_samples"]
        pub type DroppedSamplesR = crate::BitReader;
        impl R {
            #[doc = "Bits 2:3 - mode"]
            #[inline(always)]
            pub fn mode(&self) -> ModeR {
                ModeR::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bit 4 - dropped_samples"]
            #[inline(always)]
            pub fn dropped_samples(&self) -> DroppedSamplesR {
                DroppedSamplesR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - start"]
            #[inline(always)]
            pub fn start(&mut self) -> StartW<RecorderControlSpec> {
                StartW::new(self, 0)
            }
            #[doc = "Bit 1 - stop"]
            #[inline(always)]
            pub fn stop(&mut self) -> StopW<RecorderControlSpec> {
                StopW::new(self, 1)
            }
            #[doc = "Bits 2:3 - mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> ModeW<RecorderControlSpec> {
                ModeW::new(self, 2)
            }
        }
        #[doc = "recorder_control\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_control::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`recorder_control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RecorderControlSpec;
        impl crate::RegisterSpec for RecorderControlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`recorder_control::R`](R) reader structure"]
        impl crate::Readable for RecorderControlSpec {}
        #[doc = "`write(|w| ..)` method takes [`recorder_control::W`](W) writer structure"]
        impl crate::Writable for RecorderControlSpec {
            type Safety = crate::Unsafe;
        }
    }
    #[doc = "recorder_next_address (r) register accessor: recorder_next_address\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_next_address::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@recorder_next_address`] module"]
    #[doc(alias = "recorder_next_address")]
    pub type RecorderNextAddress = crate::Reg<recorder_next_address::RecorderNextAddressSpec>;
    #[doc = "recorder_next_address"]
    pub mod recorder_next_address {
        #[doc = "Register `recorder_next_address` reader"]
        pub type R = crate::R<RecorderNextAddressSpec>;
        #[doc = "Field `next_address` reader - next_address"]
        pub type NextAddressR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - next_address"]
            #[inline(always)]
            pub fn next_address(&self) -> NextAddressR {
                NextAddressR::new(self.bits)
            }
        }
        #[doc = "recorder_next_address\n\nYou can [`read`](crate::Reg::read) this register and get [`recorder_next_address::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RecorderNextAddressSpec;
        impl crate::RegisterSpec for RecorderNextAddressSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`recorder_next_address::R`](R) reader structure"]
        impl crate::Readable for RecorderNextAddressSpec {}
    }
    #[doc = "spectrometer (rw) register accessor: spectrometer\n\nYou can [`read`](crate::Reg::read) this register and get [`spectrometer::R`]. You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`spectrometer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@spectrometer`] module"]
    #[doc(alias = "spectrometer")]
    pub type Spectrometer = crate::Reg<spectrometer::SpectrometerSpec>;
    #[doc = "spectrometer"]
    pub mod spectrometer {
        #[doc = "Register `spectrometer` reader"]
        pub type R = crate::R<SpectrometerSpec>;
        #[doc = "Register `spectrometer` writer"]
        pub type W = crate::W<SpectrometerSpec>;
        #[doc = "Field `integrations_exp` reader - integrations_exp"]
        pub type IntegrationsExpR = crate::FieldReader<u16>;
        #[doc = "Field `integrations_exp` writer - integrations_exp"]
        pub type IntegrationsExpW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        #[doc = "Field `abort` writer - abort"]
        pub type AbortW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `last_buffer` reader - last_buffer"]
        pub type LastBufferR = crate::FieldReader;
        #[doc = "Field `kurt_coeff_1` reader - kurt_coeff_1"]
        pub type KurtCoeff1R = crate::FieldReader;
        #[doc = "Field `kurt_coeff_1` writer - kurt_coeff_1"]
        pub type KurtCoeff1W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        #[doc = "Field `kurt_coeff_2` reader - kurt_coeff_2"]
        pub type KurtCoeff2R = crate::FieldReader;
        #[doc = "Field `kurt_coeff_2` writer - kurt_coeff_2"]
        pub type KurtCoeff2W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        impl R {
            #[doc = "Bits 0:9 - integrations_exp"]
            #[inline(always)]
            pub fn integrations_exp(&self) -> IntegrationsExpR {
                IntegrationsExpR::new((self.bits & 0x03ff) as u16)
            }
            #[doc = "Bits 11:13 - last_buffer"]
            #[inline(always)]
            pub fn last_buffer(&self) -> LastBufferR {
                LastBufferR::new(((self.bits >> 11) & 7) as u8)
            }
            #[doc = "Bits 14:18 - kurt_coeff_1"]
            #[inline(always)]
            pub fn kurt_coeff_1(&self) -> KurtCoeff1R {
                KurtCoeff1R::new(((self.bits >> 14) & 0x1f) as u8)
            }
            #[doc = "Bits 19:23 - kurt_coeff_2"]
            #[inline(always)]
            pub fn kurt_coeff_2(&self) -> KurtCoeff2R {
                KurtCoeff2R::new(((self.bits >> 19) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - integrations_exp"]
            #[inline(always)]
            pub fn integrations_exp(&mut self) -> IntegrationsExpW<SpectrometerSpec> {
                IntegrationsExpW::new(self, 0)
            }
            #[doc = "Bit 10 - abort"]
            #[inline(always)]
            pub fn abort(&mut self) -> AbortW<SpectrometerSpec> {
                AbortW::new(self, 10)
            }
            #[doc = "Bits 14:18 - kurt_coeff_1"]
            #[inline(always)]
            pub fn kurt_coeff_1(&mut self) -> KurtCoeff1W<SpectrometerSpec> {
                KurtCoeff1W::new(self, 14)
            }
            #[doc = "Bits 19:23 - kurt_coeff_2"]
            #[inline(always)]
            pub fn kurt_coeff_2(&mut self) -> KurtCoeff2W<SpectrometerSpec> {
                KurtCoeff2W::new(self, 19)
            }
        }
        #[doc = "spectrometer\n\nYou can [`read`](crate::Reg::read) this register and get [`spectrometer::R`](R). You can [`write_with_zero`](crate::Reg::write_with_zero) this register using [`spectrometer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SpectrometerSpec;
        impl crate::RegisterSpec for SpectrometerSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`spectrometer::R`](R) reader structure"]
        impl crate::Readable for SpectrometerSpec {}
        #[doc = "`write(|w| ..)` method takes [`spectrometer::W`](W) writer structure"]
        impl crate::Writable for SpectrometerSpec {
            type Safety = crate::Unsafe;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "Maia SDR"]
    pub maia_sdr: MaiaSdr,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            maia_sdr: MaiaSdr::steal(),
        }
    }
}
